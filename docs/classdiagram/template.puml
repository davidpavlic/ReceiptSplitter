@startuml
'https://plantuml.com/class-diagram
skinparam ClassAttributeIconSize 0
skinparam groupInheritance 1

legend bottom left
<size:9> Version 2024-02-23</size>
end legend

class Car {
  - id : char {readonly}
  - currentPosition : PositionVector
  - currentVelocity : PositionVector
  - moveStrategy : MoveStrategy
  - isCrashed : boolean
  - isWinner : boolean
  - crossedWrongSide : boolean
  ---
  + Car(id : char, startPosition : PositionVector)
  ---
  + accelerate(direction : Direction)
  + nextPosition() : PositionVector
  + move()
  + crash(position : PositionVector)
  + isCrashed() : boolean
  + setWinner() : boolean
  + isCrossedWrongSide() : boolean
}


class Track {
  + {static} MAX_CARS : int
  + height : int {readonly}
  + width : int {readonly}
  ---
  Track (trackFile : File)
  ---
  - loadTrack(trackFile : File)
  + getCarCount() : int
  + getCar(carIndex : int) : Car
  + getSpaceTypeAtPosition(position : PositionVector) : SpaceType
  + getCharRepresentationAtPosition(row : int, col : int) : char
  + toString() : String
}


enum SpaceType <<enumeration>> {
  WALL '#'
  TRACK ' '
  FINISH_LEFT '<'
  FINISH_RIGHT ">"
  FINISH_UP "^"
  FINISH_DOWN "v"
  ---
  spaceChar : char
  ---
  + {static} spaceTypeForChar(spaceChar : char) : SpaceType
}

class GameManager {
  - ConsoleUserInterface : ConsoleUserInterface
  - config : Config
  ---
  + GameManager(userInterface : UserInterface, config : Config)
  ---
  + main(args: String[])
  + setup() : Game
  - setMoveStrategyForCar(selectedStrategyType : StrategyType, selectedTrackName : String, game : Game, currentCarIndex : int)
  - generateMoveFile(trackName : String, carId : char) : File
  - getAvailableDirectoryItems(directory : Path)
  - generateFile(directory : File, filename : String) : File
}

class Game {
  - {static}NO_WINNER : int
  - track : Track
  - currentCarIndex : int {readonly}
  - ConsoleUserInterface : ConsoleUserInterface {readonly}
  ---
  + Game(track : Track, userInterface : UserInterface)
  ---
  + startGame()
  + setCarMoveStrategy(carIndex : int, moveStrategy : MoveStrategy)
  + doCarTurn(acceleration : Direction)
  + switchToNextActiveCar()
  + getCarCount() : int
  + getCarId(carIndex : int) : char
  + getCarPosition(carIndex : int) : PositionVector
  + getCarVelocity(carIndex : int) : PositionVector
  + getNextCarMove(carIndex : int) : Direction
  + getWinner() : int
  + nextCarMove(carIndex : int) : Direction
  + setCarMoveStrategy(carIndex : int, carMoveStrategy : MoveStrategy) : boolean
  + calculatePath(startPosition : PositionVector, endPosition : PositionVector) : List<Direction>
  - isPositionOccupiedByOtherCar(position : PositionVector, currentCarId : char) : boolean
  - checkAndSetRemainingCarAsWinner()
  - handleFinishLineCrossing(currentCar : Car, finishType: SpaceType, ) : boolean
  - handleUserMoveStrategy(userMoveStrategy: UserMoveStrategy) : boolean
  - isWrongDirection(car: Car, finishType SpaceType): boolean
}

class ConsoleUserInterface {
  - textIO : TextIO {readonly}
  - terminal : TextTerminal<?> {readonly}
  ---
  + UserInterface()
  ---
  + getRaceTrack(trackFilenames : List<String>) : String
  + getCarStrategyType(carNumber : int, carIndex : char) : StrategyType
  + getPathFollower(pathFollowerFiles : List<String>)
  + getMenuChoice(menuItems : List <String>)
  + printErrorMessage(message : String)
  + printNoTracksFound()
  + closeTerminal()
  + printTrack(track : Track)
  + selectPlayerMove() : char
  + printInGameMenuExtended()
  + printPlayingCar(carId : char, carNumber : int)
  + printWinner(carId : char, carNumber : int)
  + printString(message : String)
  + waitForEnterPress()
}

class Config {
   + trackDirectory : File
   + moveDirectory : File
   + followerDirectory : File
}

class PositionVector {
  + x : int {readonly}
  + y : int {readonly}
  ---
  PositionVector(x : int, y : int)
  PositionVector(other : PositionVector)
  ---
  + add(other : PositionVector)
  + subtract(other : PositionVector)
  + {static} parsePositionVector(positionString : String)
}

package "strategy" {
    interface MoveStrategy {
      + nextMove() : Direction
    }

    enum StrategyType <<enumeration>> {
      DO_NOT_MOVE
      USER
      MOVE_LIST
      PATH_FOLLOWER
      PATH_FINDER
    }

    StrategyType <-* MoveStrategy

    class DoNotMoveStrategy implements MoveStrategy {
      + nextMove() : Direction
    }

    class MoveListStrategy implements MoveStrategy {
      - moves : Queue<Direction>
      ---
      + MoveListStrategy(movesFile : File)
      ---
      + nextMove() : Direction
    }

    class UserMoveStrategy implements MoveStrategy {
      + nextMove() : Direction
      + selectDirection(selectDirection : char) : Direction
    }

    class PathFollowerStrategy implements MoveStrategy {
      - bresenhamAlgorithm : BresenhamAlgorithm
      - points : Queue<PositionVector> {readonly}
      - <u> pointFilePattern : Pattern {readonly}
      - currentPosition : PositionVector
      -  currentVelocity : PositionVector
      - pathToFollow : List<PositionVector>
      ---
      + PathFollowerMoveStrategy(pathFollowerFile : File, currentPosition : PositionVector )
      - initializePoints(pathFollowerFile : File)
      + updatePointList() : boolean
      - sumSignFunction(limit : int)
      - calculateDimensionSpeed( currentPosition : int, currentVelocity : int, nextPoint : int) : int
      - generateDirection() : Direction
      + nextMove() : Direction
    }

    class PathFinder implements MoveStrategy {
   - track : Track
   - carPosition : PositionVector
    - passableFields : char[][]
    - rootNode TreeNode
    - points : Queue<PositionVector>
    - pathFollowerStrategy PathFollowerStrategy
    + nextMove() : Direction
    + PathFinderStrategy(carPosition: PositionVector, track : Track)
    - calculatePath()
    - findPath()
    - setSecondLayer(childNodes : List<TreeNode>
    - setRootNode()
    - processNodeChildren(parentNode : TreeNode) : boolean
    - passToPathFollower()
    - optimizePath() : List<PositionVector>
    - isWallBetween(point1 : PositionVector, point2 : PositionVector) : boolean
    - isFinishSign(sign char) : boolean
    - checkFinishDirection(sign char, node TreeNode) : boolean
    - calculatePassableFields(charRepresentation : char[][])
--
    - TreeNode
--
    -  value : PositionVector
    - layer : int
    - parent : TreeNode
    - childNodes : List<TreeNode>
--
    - addChild(childNode : TreeNode)
    - removeChild(childNode : TreeNode)
    + backtrackToRoot(node : TreeNode) : LinkedList<PositionVector> {readonly}
        }
}

class BresenhamAlgorithm {
  + calculatePath(startPosition : PositionVector, endPosition : PositionVector) : List<Direction>
}

'GameSpecification ()-- Game
'TrackSpecification ()-- Track
'CarSpecification ()-- Car

'hidden relations for better placement of Config and Game
'(remove when linking to other classes)
GameManager o-> Game
GameManager o-> ConsoleUserInterface
GameManager o-> Config

Config -[hidden]- Game
Game -[hidden]- Config
Game .[hidden]..> MoveStrategy
Game o-> Track

Track *-- SpaceType
Track *- Car
Car o--> MoveStrategy

Car --> PositionVector
Track --> PositionVector

PathFollowerStrategy --> BresenhamAlgorithm

@enduml
